#include "ros/ros.h"
// darknet_ros_msgs
#include <depthGet/BoundingBoxes.h>
#include <depthGet/BoundingBox.h>
#include <depthGet/BboxL.h>
#include <depthGet/BboxLes.h>
#include <iostream>
// PCL specific includes
#include <sensor_msgs/PointCloud2.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/filters/passthrough.h>
#include <pcl/io/pcd_io.h>
#include <pcl/visualization/cloud_viewer.h>
//opencv
#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <opencv2/opencv.hpp>
#include <cv_bridge/cv_bridge.h>

#include <stdio.h>
#include <sstream>
#include <vector>

#include <iostream>
#include <cstdlib>
#include <ctime>
#include <algorithm>
//#define random(a,b) (rand()%(b-a+1)+a)

#include <map>
#include <random>
#include <chrono>
#include <fstream>

#include <opencv2/core.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/highgui.hpp>

#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>

#include "depthGet/tracker.h"
#include "depthGet/utils.h"

class DepthHandler
{
 public:
    DepthHandler():it(nh)
    {
     //image_transport::ImageTransport it(nh);
     sub1= it.subscribe("/kitti_player/color/left/image_rect", 200, &DepthHandler::PictureCB, this);
     sub2= nh.subscribe("/darknet_ros/bounding_boxes", 200, &DepthHandler::BBcb, this);
     sub3= nh.subscribe("ROIL2D", 10, &DepthHandler::ROIL2Dcb, this);

     pub1= it.advertise("depthMap", 1);
     pub2= it.advertise("Tracking", 1);

     }
     std::vector<depthGet::BboxL> BBL;
	 std::vector<depthGet::BboxL> BBR;
     cv::Mat dstImage;
     cv::Mat trkImage;
     cv_bridge::CvImagePtr cv_ptr;
     std::vector<depthGet::BoundingBox> BBoxes;
	 Tracker tracker_L, tracker_R, tracker_C;
	 std::vector<cv::Rect> detections_L, detections_R, detections_C;
     std::map<int,double> old_fangcha_L, old_fangcha_R, old_fangcha_C;
	 int frame_index=0;
     std::ofstream output_file, fangcha_C_out, x_y;

     //std::vector<cv::Scalar> colors;
        
	 //主要的融合部分代码.........................................................................
    void PictureCB(const sensor_msgs::ImageConstPtr& msg)
    {
         output_file.open("/home/vincent/sensor_fusion/output.txt",ios::app);
         fangcha_C_out.open("/home/vincent/sensor_fusion/fangcha_C.txt",ios::app);
         x_y.open("/home/vincent/sensor_fusion/x_y.txt",ios::app);
         double weight_L, weight_R, weight_C;
         weight_L=0.3333333;
         weight_R=0.3333333;
         weight_C=0.3333334;
         double fangcha_max=0.6730585, fangcha_min=0.639224;
         double tuichu=0.15;
         double fangcha_0=0.65614125;
         int count_L=0, count_R=0, count_C=0;
         int count_L_it=0, count_R_it=0, count_C_it=0;
         double fangcha_average_L=0, fangcha_average_R=0, fangcha_average_C=0;
         double fangcha_average_L_it=0, fangcha_average_R_it=0, fangcha_average_C_it=0;
         double fangcha_men=fangcha_max-fangcha_0;//偏差门限值
         std::vector<double> fangcha_L,fangcha_R,fangcha_C;
         std::map<int,double> new_fangcha_L, new_fangcha_R, new_fangcha_C;
         /*if (output_file.is_open()) {
            std::cout << "Result will be exported to " << "/home/vincent/sensor_fusion/output.txt" << std::endl;
        } else {
            std::cerr << "Unable to open output file" << std::endl;
            //return -1;
        }*/
        /*if(frame_index==0){
            std::random_device rd;  //Will be used to obtain a seed for the random number engine
            std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
            constexpr int max_random_value = 20;
            std::uniform_int_distribution<> dis(0, max_random_value);
            constexpr int factor = 255 / max_random_value;

            for (int n = 0; n < kNumColors; ++n) {
            //Use dis to transform the random unsigned int generated by gen into an int in [0, 7]
            colors.emplace_back(cv::Scalar(dis(gen) * factor, dis(gen) * factor, dis(gen) * factor));
            }
        }*/
		frame_index++;
        cv_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
//      cv::imshow("OPENCV_WINDOW",cv_ptr->image); 
        dstImage= cv_ptr->image;
        trkImage= dstImage.clone();
   	//画激光雷达框 蓝色
	   detections_L.clear();
         for(int i=0;i<BBL.size();++i)
        {
           // BBL[i].maxx=BBL[i].maxx+rand()%101-50;
		   // BBL[i].minx=BBL[i].minx+rand()%101-50;
		   // BBL[i].maxy=BBL[i].maxy+rand()%101-50;
		   // BBL[i].miny=BBL[i].miny+rand()%101-50;
                float width= BBL[i].maxx- BBL[i].minx;
                float height=  BBL[i].maxy- BBL[i].miny;
				cv::Rect rect_L(BBL[i].minx,BBL[i].miny,width,height);
		 		cv::rectangle(dstImage,cv::Rect(BBL[i].minx,BBL[i].miny,width,height),cv::Scalar(255,0,0),1,1,0);
				detections_L.push_back(rect_L);
                x_y << "L," << BBL[i].minx << "," << BBL[i].miny << std::endl;


	
/*	//设置绘制文本的相关参数  
                std::string text = "navi:"+ std::to_string(int(BBL[i].navi))+" "+"x:"+std::to_string(int(BBL[i].centerx))+ " "+"y:"+ std::to_string(int(BBL[i].centery));
                int font_face = cv::FONT_HERSHEY_COMPLEX;
                double font_scale = 0.5;  //大小
                int thickness = 1;
                int baseline;
                //获取文本框的长宽  
                cv::Size text_size = cv::getTextSize(text, font_face, font_scale, thickness, &baseline);
                cv::Point origin;
                origin.x = BBL[i].minx;// - text_size.width / 2;  
                origin.y = BBL[i].miny - text_size.height / 2;
                cv::putText(dstImage, text, origin, font_face, font_scale, cv::Scalar(0, 255, 255), thickness, 8, 0);
*/
	}
	//激光雷达框跟踪
		tracker_L.Run(detections_L);
		const auto tracks_L = tracker_L.GetTracks();
		//for(auto &trk_L : tracks_L){
			//const auto &bbox_L = trk_L.second.GetStateAsBbox();
			//if (trk_L.second.coast_cycles_ < kMaxCoastCycles
                //&& (trk_L.second.hit_streak_ >= kMinHits || frame_index < kMinHits)) {
                    // Print to terminal for debugging
                    //std::cout << frame_index << "," << trk_L.first << "," << bbox_L.tl().x << "," << bbox_L.tl().y
                             // << "," << bbox_L.width << "," << bbox_L.height << ",1,-1,-1,-1"
                            //  << " Hit Streak = " << trk_L.second.hit_streak_
                             // << " Coast Cycles = " << trk_L.second.coast_cycles_ << std::endl;

                    // Export to text file for metrics evaluation
                    //output_file << frame_index << "," << "L" << "," << trk_L.first << "," << bbox_L.tl().x << "," << bbox_L.tl().y
                             //   << "," << bbox_L.width << "," << bbox_L.height << ",1,-1,-1,-1\n";

//                output_file_NIS << trk.second.GetNIS() << "\n";
               // }
		//}
                
                for (auto &trk_L : tracks_L) {
                    //output_file<<"L,"<<trk_L.first<<","<<*(trk_L.second.kf_.P_.data())<<"\n";
                    /*for(int i=1;i<trk_L.second.kf_.P_.size();i++){
                        if ((i-1)%9==0){
                            std::cout<<*(trk_L.second.kf_.P_.data()+i)<<" ";
                        }
                    }
                    std::cout<<endl;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*/
                    //std::cout<<trk_L.second.kf_.P_<<std::endl<<std::endl;
                    // only draw tracks which meet certain criteria
                    if (trk_L.second.coast_cycles_ < kMaxCoastCycles &&
                        (trk_L.second.hit_streak_ >= kMinHits || frame_index < kMinHits)) {
                        fangcha_L.push_back(*(trk_L.second.kf_.P_.data()));//0位输出
                        new_fangcha_L.insert(std::pair<int,double> (trk_L.first, *(trk_L.second.kf_.P_.data())));
                        const auto &bbox_L = trk_L.second.GetStateAsBbox();
                        cv::putText(trkImage, "L"+std::to_string(trk_L.first), cv::Point(bbox_L.tl().x, bbox_L.tl().y - 10),
                                    cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(255, 0, 0), 1);
                        //cv::rectangle(trkImage, bbox_L, colors[trk_L.first % kNumColors], 3);
                        cv::rectangle(trkImage, bbox_L, cv::Scalar(255,0,0), 2);
                    }
                    
                }


	//画毫米波雷达框 绿色
	detections_R.clear();
		for(int i=0;i<BBR.size();++i)
        {
                float width= BBR[i].maxx- BBR[i].minx;
                float height=  BBR[i].maxy- BBR[i].miny;
				cv::Rect rect_R(BBR[i].minx,BBR[i].miny,width,height);
		 		cv::rectangle(dstImage,cv::Rect(BBR[i].minx,BBR[i].miny,width,height),cv::Scalar(0,255,0),1,1,0);
				detections_R.push_back(rect_R);
                x_y << "R," << BBR[i].minx << "," << BBR[i].miny << std::endl;
		}
	//毫米波雷达跟踪
		tracker_R.Run(detections_R);
		const auto tracks_R = tracker_R.GetTracks();
		//for(auto &trk_R : tracks_R){
			//const auto &bbox_R = trk_R.second.GetStateAsBbox();
			//if (trk_R.second.coast_cycles_ < kMaxCoastCycles
               // && (trk_R.second.hit_streak_ >= kMinHits || frame_index < kMinHits)) {
                    // Print to terminal for debugging
                    //std::cout << frame_index << "," << trk_R.first << "," << bbox_R.tl().x << "," << bbox_R.tl().y
                             // << "," << bbox_R.width << "," << bbox_R.height << ",1,-1,-1,-1"
                             // << " Hit Streak = " << trk_R.second.hit_streak_
                             // << " Coast Cycles = " << trk_R.second.coast_cycles_ << std::endl;

                    // Export to text file for metrics evaluation
                   // output_file << frame_index<< "," << "R" << "," << trk_R.first << "," << bbox_R.tl().x << "," << bbox_R.tl().y
                               // << "," << bbox_R.width << "," << bbox_R.height << ",1,-1,-1,-1\n";

//                output_file_NIS << trk.second.GetNIS() << "\n";
              //  }
	//	}

                for (auto &trk_R : tracks_R) {
                    //output_file<<"R,"<<trk_R.first<<","<<*(trk_R.second.kf_.P_.data())<<"\n";
                    // only draw tracks which meet certain criteria
                    if (trk_R.second.coast_cycles_ < kMaxCoastCycles &&
                        (trk_R.second.hit_streak_ >= kMinHits || frame_index < kMinHits)) {
                        fangcha_R.push_back(*(trk_R.second.kf_.P_.data()));
                        new_fangcha_R.insert(std::pair<int,double> (trk_R.first, *(trk_R.second.kf_.P_.data())));
                        const auto &bbox_R = trk_R.second.GetStateAsBbox();
                        cv::putText(trkImage, "R"+std::to_string(trk_R.first), cv::Point(bbox_R.tl().x, bbox_R.tl().y - 10),
                                    cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(0, 255, 0), 1);
                        //cv::rectangle(trkImage, bbox_R, colors[trk_R.first % kNumColors], 3);
                        cv::rectangle(trkImage, bbox_R, cv::Scalar(0,255,0), 2);
                    }
                }

	//画yolo框
		detections_C.clear();
         for(int i=0;i<BBoxes.size();++i)
        {
           if(BBoxes[i].probability>0.4)
           {
                //msg->bounding_boxes[1].xmin
                // ROS_INFO("I heard: [%d]",msg->bounding_boxes[1].xmin);       
        		float width = BBoxes[i].xmax- BBoxes[i].xmin;
                float height =  BBoxes[i].ymax- BBoxes[i].ymin;
				cv::Rect rect_C(BBoxes[i].xmin,BBoxes[i].ymin,width,height);
                cv::rectangle(dstImage,cv::Rect(BBoxes[i].xmin,BBoxes[i].ymin,width,height),cv::Scalar(0,0,255),1,1,0);
				detections_C.push_back(rect_C);
                x_y << "C," << BBoxes[i].xmin << "," << BBoxes[i].ymin << std::endl;
    /*            //设置绘制文本的相关参数  
                std::string text = BBoxes[i].Class+"-"+std::to_string(int(100*BBoxes[i].probability))+"%";
                int font_face = cv::FONT_HERSHEY_COMPLEX;
                double font_scale = 0.5;  //大小
                int thickness = 1;
                int baseline;
                //获取文本框的长宽  
                cv::Size text_size = cv::getTextSize(text, font_face, font_scale, thickness, &baseline);
                cv::Point origin;
                origin.x = BBoxes[i].xmin;// - text_size.width / 2;  
                origin.y = BBoxes[i].ymin - text_size.height / 2;
                cv::putText(dstImage, text, origin, font_face, font_scale, cv::Scalar(0, 255, 255), thickness, 8, 0);*/
          }
        }
		//yolo框跟踪
        tracker_C.Run(detections_C);
		const auto tracks_C = tracker_C.GetTracks();
		//for(auto &trk_C : tracks_C){
			//const auto &bbox_C = trk_C.second.GetStateAsBbox();
			//if (trk_C.second.coast_cycles_ < kMaxCoastCycles
               // && (trk_C.second.hit_streak_ >= kMinHits || frame_index < kMinHits)) {
                    // Print to terminal for debugging
                    //std::cout << frame_index << "," << trk_C.first << "," << bbox_C.tl().x << "," << bbox_C.tl().y
                            //  << "," << bbox_C.width << "," << bbox_C.height << ",1,-1,-1,-1"
                            //  << " Hit Streak = " << trk_C.second.hit_streak_
                             // << " Coast Cycles = " << trk_C.second.coast_cycles_ << std::endl;

                    // Export to text file for metrics evaluation
                   // output_file << frame_index<< "," << "C" << "," << trk_C.first << "," << bbox_C.tl().x << "," << bbox_C.tl().y
                             //   << "," << bbox_C.width << "," << bbox_C.height << ",1,-1,-1,-1\n";

//                output_file_NIS << trk.second.GetNIS() << "\n";
               // }
		//}

                for (auto &trk_C : tracks_C) {
                    
                    //std::cout<<trk_C.first<<","<<*(trk_C.second.kf_.P_.data())<<",";//0位输出
                    //output_file<<"c,"<<trk_C.first<<","<<*(trk_C.second.kf_.P_.data())<<"\n";
                    //for(int i=1;i<trk_C.second.kf_.P_.size();i++){
                    //    if (i%9==0){
                    //        std::cout<<*(trk_C.second.kf_.P_.data()+i)<<",";
                    //        output_file<<*(trk_C.second.kf_.P_.data()+i)<<",";
                    //    }
                    //}
                    //std::cout<<endl;
                    //output_file<<"\n";
                    // only draw tracks which meet certain criteria
                    if (trk_C.second.coast_cycles_ < kMaxCoastCycles &&
                        (trk_C.second.hit_streak_ >= kMinHits || frame_index < kMinHits)) {
                        fangcha_C.push_back(*(trk_C.second.kf_.P_.data()));
                        new_fangcha_C.insert(std::pair<int,double> (trk_C.first, *(trk_C.second.kf_.P_.data())));
                        const auto &bbox_C = trk_C.second.GetStateAsBbox();
                        cv::putText(trkImage, "C"+std::to_string(trk_C.first), cv::Point(bbox_C.tl().x, bbox_C.tl().y - 10),
                                    cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(0, 0, 255), 1);
                        //cv::rectangle(trkImage, bbox_C, colors[trk_C.first % kNumColors], 3);
                        cv::rectangle(trkImage, bbox_C, cv::Scalar(0,0,255), 2);
                        fangcha_C_out<<trk_C.first<<","<< *(trk_C.second.kf_.P_.data())<<endl;
                    }
                }


    //=====================权重分配
    if(frame_index>3){//第三帧之后再进行权重动态分配及退出
    for(auto &new_L : new_fangcha_L){
		if(new_L.second<fangcha_min||new_L.second>fangcha_max){
            count_L++;   
        }
            
        else{//记录与中间值的偏差
            auto iter = old_fangcha_L.find(new_L.first);
            if(iter != old_fangcha_L.end()){
                double temp_it=std::max(iter->second,new_L.second)-std::min(iter->second,new_L.second);
                fangcha_average_L_it=fangcha_average_L_it+temp_it;
            }
            else
                count_L_it++;
            double temp=std::max(fangcha_0,new_L.second)-std::min(fangcha_0,new_L.second);
            fangcha_average_L=fangcha_average_L+temp;
        }

    }
    if(fangcha_L.size()==0){
        weight_L=0.000000;
    }
    else{
        if(count_L/fangcha_L.size()>=tuichu || fangcha_L.size()==count_L || fangcha_L.size()==(count_L+count_L_it))//激光雷达超范围的占15%，激光雷达退出
            weight_L=0.000000;
        else{
            fangcha_average_L=fangcha_average_L/(fangcha_L.size()-count_L);
            fangcha_average_L_it=fangcha_average_L_it/(fangcha_L.size()-count_L-count_L_it);
        }
    }
     for(auto &new_R : new_fangcha_R){
		if(new_R.second<fangcha_min||new_R.second>fangcha_max){
            count_R++;   
        }
            
        else{//记录与中间值的偏差
            auto iter = old_fangcha_R.find(new_R.first);
            if(iter!=old_fangcha_R.end()){
            double temp_it=std::max(iter->second,new_R.second)-std::min(iter->second,new_R.second);
            fangcha_average_R_it=fangcha_average_R_it+temp_it;
            }
            else
                count_R_it++;
            double temp=std::max(fangcha_0,new_R.second)-std::min(fangcha_0,new_R.second);
            fangcha_average_R=fangcha_average_R+temp;
        }

    }
    if(fangcha_R.size()==0){
        weight_R=0.000000;
    }
    else{
        if(count_R/fangcha_R.size()>=tuichu || fangcha_R.size()==count_R || fangcha_R.size()==(count_R+count_R_it))//激光雷达超范围的占15%，激光雷达退出
            weight_R=0.000000;
        else{
            fangcha_average_R=fangcha_average_R/(fangcha_R.size()-count_R);
            fangcha_average_R_it=fangcha_average_R_it/(fangcha_R.size()-count_R-count_R_it);
        }
    }
     for(auto &new_C : new_fangcha_C){
		if(new_C.second<fangcha_min||new_C.second>fangcha_max){
            count_C++;   
        }
            
        else{//记录与中间值的偏差
            auto iter = old_fangcha_C.find(new_C.first);
            if(iter!=old_fangcha_C.end()){
            double temp_it=std::max(iter->second,new_C.second)-std::min(iter->second,new_C.second);
            fangcha_average_C_it=fangcha_average_C_it+temp_it;
            }
            else
                count_C_it++;
            double temp=std::max(fangcha_0,new_C.second)-std::min(fangcha_0,new_C.second);
            fangcha_average_C=fangcha_average_C+temp;
        }

    }
    if(fangcha_C.size()==0){
        weight_C=0.000000;
    }
    else{
        if(count_C/fangcha_C.size()>=tuichu || fangcha_C.size()==count_C || fangcha_C.size()==(count_C+count_C_it))//激光雷达超范围的占15%，激光雷达退出
            weight_C=0.000000;
        else{
            fangcha_average_C=fangcha_average_C/(fangcha_C.size()-count_C);
            fangcha_average_C_it=fangcha_average_C_it/(fangcha_C.size()-count_C-count_C_it);
        }
    }
    /*for(int i=0;i<fangcha_R.size();i++){
		if(fangcha_R[i]<fangcha_min||fangcha_R[i]>fangcha_max)
            count_R++;
        else{//记录与中间值的偏差
            double temp=std::max(fangcha_0,fangcha_R[i])-std::min(fangcha_0,fangcha_R[i]);
            fangcha_average_R=fangcha_average_R+temp;
        }
    }
    if(fangcha_R.size()==0){
        weight_R=0.000000;
    }
    else{
        if(count_R/fangcha_R.size()>=tuichu)//该帧毫米波超范围的占15%，毫米波退出
            weight_R=0.000000;
        else
            fangcha_average_R=fangcha_average_R/(fangcha_R.size()-count_R);
    }
    for(int i=0;i<fangcha_C.size();i++){
		if(fangcha_C[i]<fangcha_min||fangcha_C[i]>fangcha_max)
            count_C++;
        else{//记录与中间值的偏差
            double temp=std::max(fangcha_0,fangcha_C[i])-std::min(fangcha_0,fangcha_C[i]);
            fangcha_average_C=fangcha_average_C+temp;
        }
    }
    if(fangcha_C.size()==0){
        weight_C=0.000000;
    }
    else{
        if(count_C/fangcha_C.size()>=tuichu)//该帧摄像头超范围的占15%，摄像头退出
            weight_C=0.000000;
        else
            fangcha_average_C=fangcha_average_C/(fangcha_C.size()-count_C);
    }*/
//权重归一化并分配
    if(weight_L!=0&&weight_R!=0&&weight_C!=0){//没有需要退出的传感器
		double fangcha_average=(fangcha_average_L+fangcha_average_R+fangcha_average_C)/3;
        double L_dev=fangcha_average-fangcha_average_L;
        double R_dev=fangcha_average-fangcha_average_R;
        double C_dev=fangcha_average-fangcha_average_C;
        double weight_L_1=0.166666+((L_dev/(fangcha_average_L+fangcha_average_R+fangcha_average_C))/2);
        double weight_R_1=0.166666+((R_dev/(fangcha_average_L+fangcha_average_R+fangcha_average_C))/2);
        double weight_C_1=0.166667+((C_dev/(fangcha_average_L+fangcha_average_R+fangcha_average_C))/2);
        double fangcha_average_it=(fangcha_average_L_it+fangcha_average_R_it+fangcha_average_C_it)/3;
        double L_dev_it=fangcha_average_it-fangcha_average_L_it;
        double R_dev_it=fangcha_average_it-fangcha_average_R_it;
        double C_dev_it=fangcha_average_it-fangcha_average_C_it;
        double weight_L_2=0.166666+((L_dev_it/(fangcha_average_L_it+fangcha_average_R_it+fangcha_average_C_it))/2);
        double weight_R_2=0.166666+((R_dev_it/(fangcha_average_L_it+fangcha_average_R_it+fangcha_average_C_it))/2);
        double weight_C_2=0.166667+((C_dev_it/(fangcha_average_L_it+fangcha_average_R_it+fangcha_average_C_it))/2);
        weight_L=weight_L_1+weight_L_2;
        weight_R=weight_R_1+weight_R_2;
        weight_C=weight_C_1+weight_C_2;
    }
    else if(weight_L==0&&weight_R!=0&&weight_C!=0){
        double fangcha_average=(fangcha_average_R+fangcha_average_C)/2;
        double R_dev=fangcha_average-fangcha_average_R;
        double C_dev=fangcha_average-fangcha_average_C;
        double weight_R_1=0.25+((R_dev/(fangcha_average_R+fangcha_average_C))/2);
        double weight_C_1=0.25+((C_dev/(fangcha_average_R+fangcha_average_C))/2);
        double fangcha_average_it=(fangcha_average_R_it+fangcha_average_C_it)/2;
        double R_dev_it=fangcha_average_it-fangcha_average_R_it;
        double C_dev_it=fangcha_average_it-fangcha_average_C_it;
        double weight_R_2=0.25+((R_dev_it/(fangcha_average_R_it+fangcha_average_C_it))/2);
        double weight_C_2=0.25+((C_dev_it/(fangcha_average_R_it+fangcha_average_C_it))/2);
        weight_R=weight_R_1+weight_R_2;
        weight_C=weight_C_1+weight_C_2;
    }
	else if(weight_L!=0&&weight_R==0&&weight_C!=0){
        double fangcha_average=(fangcha_average_L+fangcha_average_C)/2;
        double L_dev=fangcha_average-fangcha_average_L;
        double C_dev=fangcha_average-fangcha_average_C;
        double weight_L_1=0.25+((L_dev/(fangcha_average_L+fangcha_average_C))/2);
        double weight_C_1=0.25+((C_dev/(fangcha_average_L+fangcha_average_C))/2);
        double fangcha_average_it=(fangcha_average_L_it+fangcha_average_C_it)/2;
        double L_dev_it=fangcha_average_it-fangcha_average_L_it;
        double C_dev_it=fangcha_average_it-fangcha_average_C_it;
        double weight_L_2=0.25+((L_dev_it/(fangcha_average_L_it+fangcha_average_C_it))/2);
        double weight_C_2=0.25+((C_dev_it/(fangcha_average_L_it+fangcha_average_C_it))/2);
        weight_L=weight_L_1+weight_L_2;
        weight_C=weight_C_1+weight_C_2;
    }
    else if(weight_L!=0&&weight_R!=0&&weight_C==0){
        double fangcha_average=(fangcha_average_L+fangcha_average_R)/2;
        double L_dev=fangcha_average-fangcha_average_L;
        double R_dev=fangcha_average-fangcha_average_R;
        double weight_L_1=0.25+((L_dev/(fangcha_average_L+fangcha_average_R))/2);
        double weight_R_1=0.25+((R_dev/(fangcha_average_L+fangcha_average_R))/2);
        double fangcha_average_it=(fangcha_average_L_it+fangcha_average_R_it)/2;
        double L_dev_it=fangcha_average_it-fangcha_average_L_it;
        double R_dev_it=fangcha_average_it-fangcha_average_R_it;
        double weight_L_2=0.25+((L_dev_it/(fangcha_average_L_it+fangcha_average_R_it))/2);
        double weight_R_2=0.25+((R_dev_it/(fangcha_average_L_it+fangcha_average_R_it))/2);
        weight_L=weight_L_1+weight_L_2;
        weight_R=weight_R_1+weight_R_2;
    }
    else if(weight_L!=0&&weight_R==0&&weight_C==0){
        weight_L=1.000000;
    }
    else if(weight_L==0&&weight_R!=0&&weight_C==0){
        weight_R=1.000000;
    }
    else if(weight_L==0&&weight_R==0&&weight_C!=0){
        weight_C=1.000000;
    }
    else if(weight_L==0&&weight_R==0&&weight_C==0){
        weight_L=0.3333333;
        weight_R=0.3333333;
        weight_C=0.3333334;
    }
    /*if(weight_L!=0&&weight_R!=0&&weight_C!=0){//没有需要退出的传感器
		double fangcha_average=(fangcha_average_L+fangcha_average_R+fangcha_average_C)/3;
        double L_dev=fangcha_average-fangcha_average_L;
        double R_dev=fangcha_average-fangcha_average_R;
        double C_dev=fangcha_average-fangcha_average_C;
        weight_L=0.333333+L_dev/(fangcha_average_L+fangcha_average_R+fangcha_average_C);
        weight_R=0.333333+R_dev/(fangcha_average_L+fangcha_average_R+fangcha_average_C);
        weight_C=0.333333+C_dev/(fangcha_average_L+fangcha_average_R+fangcha_average_C);
    }
    else if(weight_L==0&&weight_R!=0&&weight_C!=0){
        double fangcha_average=(fangcha_average_R+fangcha_average_C)/2;
        double R_dev=fangcha_average-fangcha_average_R;
        double C_dev=fangcha_average-fangcha_average_C;
        weight_R=0.5+R_dev/(fangcha_average_R+fangcha_average_C);
        weight_C=0.5+C_dev/(fangcha_average_R+fangcha_average_C);
    }
	else if(weight_L!=0&&weight_R==0&&weight_C!=0){
        double fangcha_average=(fangcha_average_L+fangcha_average_C)/2;
        double L_dev=fangcha_average-fangcha_average_L;
        double C_dev=fangcha_average-fangcha_average_C;
        weight_L=0.5+L_dev/(fangcha_average_L+fangcha_average_C);
        weight_C=0.5+C_dev/(fangcha_average_L+fangcha_average_C);
    }
    else if(weight_L!=0&&weight_R!=0&&weight_C==0){
        double fangcha_average=(fangcha_average_L+fangcha_average_R)/2;
        double L_dev=fangcha_average-fangcha_average_L;
        double R_dev=fangcha_average-fangcha_average_R;
        weight_L=0.5+L_dev/(fangcha_average_L+fangcha_average_R);
        weight_R=0.5+R_dev/(fangcha_average_L+fangcha_average_R);
    }
    else if(weight_L!=0&&weight_R==0&&weight_C==0){
        weight_L=1.000000;
    }
    else if(weight_L==0&&weight_R!=0&&weight_C==0){
        weight_R=1.000000;
    }
    else if(weight_L==0&&weight_R==0&&weight_C!=0){
        weight_C=1.000000;
    }
    else if(weight_L==0&&weight_R==0&&weight_C==0){
        weight_L=0.3333333;
        weight_R=0.3333333;
        weight_C=0.3333334;
    }*/

}//end if(frame>3)
    old_fangcha_L.clear();
    old_fangcha_R.clear();
    old_fangcha_C.clear();
    old_fangcha_L=new_fangcha_L;
    old_fangcha_R=new_fangcha_R;
    old_fangcha_C=new_fangcha_C;
    std::cout<<"weight_C = "<<weight_C<<", "<<"weight_L = "<<weight_L<<", "<<"weight_R = "<<weight_R<<std::endl<<std::endl;
	//==================画融合框
    output_file<<weight_C<<", "<<weight_L<<", "<<weight_R<<std::endl;
	finalbox fusionfbox;	
    if(weight_L!=0&&weight_R!=0&&weight_C!=0){
        for(int i=0;i<BBoxes.size();++i)
	    {
	    if(BBoxes[i].probability>0.4)
           {
		    float lengthc= BBoxes[i].xmax- BBoxes[i].xmin;
            float widthc=  BBoxes[i].ymax- BBoxes[i].ymin;
	  	    for(int k=0;k<BBL.size();++k)
	        {
                float lengthl= BBL[k].maxx- BBL[k].minx;
                float widthl=  BBL[k].maxy- BBL[k].miny;
                for(int j=0;j<BBR.size();++j)
                    {
                        float lengthr= BBR[j].maxx- BBR[j].minx;
                        float widthr=  BBR[j].maxy- BBR[j].miny;
		                bool fumaxx=(BBoxes[i].xmax-BBL[k].maxx<lengthc/2)&&(BBoxes[i].xmax-BBL[k].maxx>-lengthc/2)&&(BBoxes[i].xmax-BBR[j].maxx<lengthc/2)&&(BBoxes[i].xmax-BBR[j].maxx>-lengthc/2)&&(BBR[j].maxx-BBL[k].maxx<lengthr/2)&&(BBR[j].maxx-BBL[k].maxx>-lengthr/2);
		                bool fuminx=(BBoxes[i].xmin-BBL[k].minx<lengthc/2)&&(BBoxes[i].xmin-BBL[k].minx>-lengthc/2)&&(BBoxes[i].xmin-BBR[j].minx<lengthc/2)&&(BBoxes[i].xmin-BBR[j].minx>-lengthc/2)&&(BBR[j].minx-BBL[k].minx<lengthr/2)&&(BBR[j].minx-BBL[k].minx>-lengthr/2);
 		                bool fuminy=(BBoxes[i].ymin-BBL[k].miny<widthc/2)&&(BBoxes[i].ymin-BBL[k].miny>-widthc/2)&&(BBoxes[i].ymax-BBR[j].maxy<widthc/2)&&(BBoxes[i].ymax-BBR[j].maxy>-widthc/2)&&(BBR[j].maxy-BBL[k].maxy<widthr/2)&&(BBR[j].maxy-BBL[k].maxy>-widthr/2);
		                bool fumaxy=(BBoxes[i].ymax-BBL[k].maxy<widthc/2)&&(BBoxes[i].ymax-BBL[k].maxy>-widthc/2)&&(BBoxes[i].ymin-BBR[j].miny<widthc/2)&&(BBoxes[i].ymin-BBR[j].miny>-widthc/2)&&(BBR[j].miny-BBL[k].miny<widthr/2)&&(BBR[j].miny-BBL[k].miny>-widthr/2);

                        if(fumaxx&&fuminx&&fuminy&&fumaxy)
                        {
                            fusionfbox.maxx=BBoxes[i].xmax*weight_C+BBL[k].maxx*weight_L+BBR[j].maxx*weight_R;
                            fusionfbox.maxy=BBoxes[i].ymax*weight_C+BBL[k].maxy*weight_L+BBR[j].maxy*weight_R;
                            fusionfbox.minx=BBoxes[i].xmin*weight_C+BBL[k].minx*weight_L+BBR[j].minx*weight_R;
                            fusionfbox.miny=BBoxes[i].ymin*weight_C+BBL[k].miny*weight_L+BBR[j].miny*weight_R;
                            fusionfbox.centerx=(fusionfbox.maxx+fusionfbox.minx)/2;
                            fusionfbox.centery=(fusionfbox.maxy+fusionfbox.miny)/2;
                            fusionfbox.navi=BBL[k].navi;
                            //fusionfbox.probability=BBoxes[i].probability;
                            fusionfbox.Class=BBoxes[i].Class;	
                            //=======draw
                            float lengthf= fusionfbox.maxx- fusionfbox.minx;
                                    float widthf=  fusionfbox.maxy- fusionfbox.miny;
                            cv::rectangle(dstImage,cv::Rect(fusionfbox.minx,fusionfbox.miny,lengthf,widthf),cv::Scalar(0,0,255),3,1,0);

                            std::string text = fusionfbox.Class+"-"+"navi:"+ std::to_string(int(fusionfbox.navi))+" "+"x:"+std::to_string(int(fusionfbox.centerx))+ " "+"y:"+ std::to_string(int(fusionfbox.centery));
                                    int font_face = cv::FONT_HERSHEY_COMPLEX;
                                    double font_scale = 0.5;  //大小
                                    int thickness = 1;
                                    int baseline;
                                    //获取文本框的长宽  
                                    cv::Size text_size = cv::getTextSize(text, font_face, font_scale, thickness, &baseline);
                                    cv::Point origin;
                                    origin.x = fusionfbox.minx;// - text_size.width / 2;  
                                    origin.y = fusionfbox.miny - text_size.height / 2;
                                    cv::putText(dstImage, text, origin, font_face, font_scale, cv::Scalar(0, 255, 255), thickness, 8, 0);

                            
                            break;
                        }
                        
                     }
                        
		        }

	        }	
	    }	
    }
    else if(weight_L!=0&&weight_R==0&&weight_C!=0){
        for(int i=0;i<BBoxes.size();++i)
	    {
	        if(BBoxes[i].probability>0.4)
            {
		        float lengthc= BBoxes[i].xmax- BBoxes[i].xmin;
                float widthc=  BBoxes[i].ymax- BBoxes[i].ymin;
	  	        for(int k=0;k<BBL.size();++k)
	            {
                    float lengthl= BBL[k].maxx- BBL[k].minx;
                    float widthl=  BBL[k].maxy- BBL[k].miny;
		
                    bool fumaxx=(BBoxes[i].xmax-BBL[k].maxx<lengthc/2)&&(BBoxes[i].xmax-BBL[k].maxx>-lengthc/2);
                    bool fuminx=(BBoxes[i].xmin-BBL[k].minx<lengthc/2)&&(BBoxes[i].xmin-BBL[k].minx>-lengthc/2);
                    bool fuminy=(BBoxes[i].ymin-BBL[k].miny<widthc/2)&&(BBoxes[i].ymin-BBL[k].miny>-widthc/2);
                    bool fumaxy=(BBoxes[i].ymax-BBL[k].maxy<widthc/2)&&(BBoxes[i].ymax-BBL[k].maxy>-widthc/2);

                    if(fumaxx&&fuminx&&fuminy&&fumaxy)
                    {
                        fusionfbox.maxx=BBoxes[i].xmax*weight_C+BBL[k].maxx*weight_L;
                        fusionfbox.maxy=BBoxes[i].ymax*weight_C+BBL[k].maxy*weight_L;
                        fusionfbox.minx=BBoxes[i].xmin*weight_C+BBL[k].minx*weight_L;
                        fusionfbox.miny=BBoxes[i].ymin*weight_C+BBL[k].miny*weight_L;
                        fusionfbox.centerx=(fusionfbox.maxx+fusionfbox.minx)/2;
                        fusionfbox.centery=(fusionfbox.maxy+fusionfbox.miny)/2;
                        fusionfbox.navi=BBL[k].navi;
                        //fusionfbox.probability=BBoxes[i].probability;
                        fusionfbox.Class=BBoxes[i].Class;	
                        //=======draw
                        float lengthf= fusionfbox.maxx- fusionfbox.minx;
                                float widthf=  fusionfbox.maxy- fusionfbox.miny;
                        cv::rectangle(dstImage,cv::Rect(fusionfbox.minx,fusionfbox.miny,lengthf,widthf),cv::Scalar(0,0,255),3,1,0);

                        std::string text = fusionfbox.Class+"-"+"navi:"+ std::to_string(int(fusionfbox.navi))+" "+"x:"+std::to_string(int(fusionfbox.centerx))+ " "+"y:"+ std::to_string(int(fusionfbox.centery));
                                int font_face = cv::FONT_HERSHEY_COMPLEX;
                                double font_scale = 0.5;  //大小
                                int thickness = 1;
                                int baseline;
                                //获取文本框的长宽  
                                cv::Size text_size = cv::getTextSize(text, font_face, font_scale, thickness, &baseline);
                                cv::Point origin;
                                origin.x = fusionfbox.minx;// - text_size.width / 2;  
                                origin.y = fusionfbox.miny - text_size.height / 2;
                                cv::putText(dstImage, text, origin, font_face, font_scale, cv::Scalar(0, 255, 255), thickness, 8, 0);

                        
                        break;
                    }
                }

	         }	
	    }
    }
	else if(weight_L==0&&weight_R!=0&&weight_C!=0){
        for(int i=0;i<BBoxes.size();++i)
	    {
	        if(BBoxes[i].probability>0.4)
            {
		        float lengthc= BBoxes[i].xmax- BBoxes[i].xmin;
                float widthc=  BBoxes[i].ymax- BBoxes[i].ymin;
	  	        for(int k=0;k<BBR.size();++k)
	            {
                    float lengthl= BBR[k].maxx- BBR[k].minx;
                    float widthl=  BBR[k].maxy- BBR[k].miny;
		
                    bool fumaxx=(BBoxes[i].xmax-BBR[k].maxx<lengthc/2)&&(BBoxes[i].xmax-BBR[k].maxx>-lengthc/2);
                    bool fuminx=(BBoxes[i].xmin-BBR[k].minx<lengthc/2)&&(BBoxes[i].xmin-BBR[k].minx>-lengthc/2);
                    bool fuminy=(BBoxes[i].ymin-BBR[k].miny<widthc/2)&&(BBoxes[i].ymin-BBR[k].miny>-widthc/2);
                    bool fumaxy=(BBoxes[i].ymax-BBR[k].maxy<widthc/2)&&(BBoxes[i].ymax-BBR[k].maxy>-widthc/2);

                    if(fumaxx&&fuminx&&fuminy&&fumaxy)
                    {
                        fusionfbox.maxx=BBoxes[i].xmax*weight_C+BBR[k].maxx*weight_R;
                        fusionfbox.maxy=BBoxes[i].ymax*weight_C+BBR[k].maxy*weight_R;
                        fusionfbox.minx=BBoxes[i].xmin*weight_C+BBR[k].minx*weight_R;
                        fusionfbox.miny=BBoxes[i].ymin*weight_C+BBR[k].miny*weight_R;
                        fusionfbox.centerx=(fusionfbox.maxx+fusionfbox.minx)/2;
                        fusionfbox.centery=(fusionfbox.maxy+fusionfbox.miny)/2;
                        fusionfbox.navi=BBR[k].navi;
                        //fusionfbox.probability=BBoxes[i].probability;
                        fusionfbox.Class=BBoxes[i].Class;	
                        //=======draw
                        float lengthf= fusionfbox.maxx- fusionfbox.minx;
                                float widthf=  fusionfbox.maxy- fusionfbox.miny;
                        cv::rectangle(dstImage,cv::Rect(fusionfbox.minx,fusionfbox.miny,lengthf,widthf),cv::Scalar(0,0,255),3,1,0);

                        std::string text = fusionfbox.Class+"-"+"navi:"+ std::to_string(int(fusionfbox.navi))+" "+"x:"+std::to_string(int(fusionfbox.centerx))+ " "+"y:"+ std::to_string(int(fusionfbox.centery));
                                int font_face = cv::FONT_HERSHEY_COMPLEX;
                                double font_scale = 0.5;  //大小
                                int thickness = 1;
                                int baseline;
                                //获取文本框的长宽  
                                cv::Size text_size = cv::getTextSize(text, font_face, font_scale, thickness, &baseline);
                                cv::Point origin;
                                origin.x = fusionfbox.minx;// - text_size.width / 2;  
                                origin.y = fusionfbox.miny - text_size.height / 2;
                                cv::putText(dstImage, text, origin, font_face, font_scale, cv::Scalar(0, 255, 255), thickness, 8, 0);

                        
                        break;
                    }
                }
int i=0;

i<fangcha_L.size();
	         }	
	    }
    }
    else if(weight_L!=0&&weight_R!=0&&weight_C==0){//还有问题
        for(int i=0;i<BBL.size();++i)
	    {
		        float lengthl=BBL[i].maxx- BBL[i].minx;
                float widthl=BBL[i].maxy- BBL[i].miny;
	  	        for(int k=0;k<BBR.size();++k)
	            {
                    float lengthr=0.0;
                     lengthr=BBR[k].maxx- BBR[k].minx;
                    float widthr=  0.0;
                      widthr=BBR[k].maxy- BBR[k].miny;  
		
                    bool fumaxx=(BBL[i].maxx-BBR[k].maxx<lengthl/2)&&(BBL[i].maxx-BBR[k].maxx>-lengthl/2);
                    bool fuminx=(BBL[i].minx-BBR[k].minx<lengthl/2)&&(BBL[i].minx-BBR[k].minx>-lengthl/2);
                    bool fuminy=(BBL[i].miny-BBR[k].miny<widthl/2)&&(BBL[i].miny-BBR[k].miny>-widthl/2);
                    bool fumaxy=(BBL[i].maxy-BBR[k].maxy<widthl/2)&&(BBL[i].maxy-BBR[k].maxy>-widthl/2);
                    if(fumaxx&&fuminx&&fuminy&&fumaxy)
                    {
                        fusionfbox.maxx=BBL[i].maxx*weight_L+BBR[k].maxx*weight_R;
                        fusionfbox.maxy=BBL[i].maxy*weight_L+BBR[k].maxy*weight_R;
                        fusionfbox.minx=BBL[i].minx*weight_L+BBR[k].minx*weight_R;
                        fusionfbox.miny=BBL[i].miny*weight_L+BBR[k].miny*weight_R;
                        fusionfbox.centerx=(fusionfbox.maxx+fusionfbox.minx)/2;
                        fusionfbox.centery=(fusionfbox.maxy+fusionfbox.miny)/2;
                        fusionfbox.navi=BBL[i].navi;
                        
                        //fusionfbox.probability=BBoxes[i].probability;
                        fusionfbox.Class="car";	
                        //=======draw
                        int lengthf= fusionfbox.maxx- fusionfbox.minx;
                        int widthf=  fusionfbox.maxy- fusionfbox.miny;
                        cv::rectangle(dstImage,cv::Rect(fusionfbox.minx,fusionfbox.miny,lengthf,widthf),cv::Scalar(0,0,255),3,1,0);

                        std::string text = fusionfbox.Class+"-"+"navi:"+ std::to_string(int(fusionfbox.navi))+" "+"x:"+std::to_string(int(fusionfbox.centerx))+ " "+"y:"+ std::to_string(int(fusionfbox.centery));
                                int font_face = cv::FONT_HERSHEY_COMPLEX;
                                double font_scale = 0.5;  //大小
                                int thickness = 1;
                                int baseline;
                                //获取文本框的长宽  
                                cv::Size text_size = cv::getTextSize(text, font_face, font_scale, thickness, &baseline);
                                cv::Point origin;
                                origin.x = fusionfbox.minx;// - text_size.width / 2;  
                                origin.y = fusionfbox.miny - text_size.height / 2;
                                cv::putText(dstImage, text, origin, font_face, font_scale, cv::Scalar(0, 255, 255), thickness, 8, 0);
                        
                        break;
                    }
                }	
	    }
    }
    else if(weight_L==0&&weight_R==0&&weight_C!=0){
        
        for(int i=0;i<BBoxes.size();++i)
	    {
	        if(BBoxes[i].probability>0.4)
            {
                        //=======draw
                        float lengthf= BBoxes[i].xmax- BBoxes[i].xmin;
                        float widthf=  BBoxes[i].ymax- BBoxes[i].ymin;
                        float centerx=(BBoxes[i].xmax+ BBoxes[i].xmin)/2;
                        float centery=(BBoxes[i].ymax+ BBoxes[i].ymin)/2;
                        cv::rectangle(dstImage,cv::Rect(BBoxes[i].xmin,BBoxes[i].ymin,lengthf,widthf),cv::Scalar(0,0,255),3,1,0);

                        std::string text = BBoxes[i].Class+"-"+"x:"+std::to_string(int(centerx))+ " "+"y:"+ std::to_string(int(centery));
                                int font_face = cv::FONT_HERSHEY_COMPLEX;
                                double font_scale = 0.5;  //大小
                                int thickness = 1;
                                int baseline;
                                //获取文本框的长宽  
                                cv::Size text_size = cv::getTextSize(text, font_face, font_scale, thickness, &baseline);
                                cv::Point origin;
                                origin.x = BBoxes[i].xmin;// - text_size.width / 2;  
                                origin.y = BBoxes[i].ymin - text_size.height / 2;
                                cv::putText(dstImage, text, origin, font_face, font_scale, cv::Scalar(0, 255, 255), thickness, 8, 0);

                        
            }
	    }
    }
    else if(weight_L==0&&weight_R!=0&&weight_C==0){
        for(int i=0;i<BBR.size();++i)
	    {	        
                        fusionfbox.maxx=BBR[i].maxx;
                        fusionfbox.maxy=BBR[i].maxy;
                        fusionfbox.minx=BBR[i].minx;
                        fusionfbox.miny=BBR[i].miny;
                        fusionfbox.centerx=(fusionfbox.maxx+fusionfbox.minx)/2;
                        fusionfbox.centery=(fusionfbox.maxy+fusionfbox.miny)/2;
                        fusionfbox.navi=BBR[i].navi;
                        //fusionfbox.probability=BBoxes[i].probability;
                        fusionfbox.Class="car";	
                        //=======draw
                        float lengthf= fusionfbox.maxx- fusionfbox.minx;
                        float widthf=  fusionfbox.maxy- fusionfbox.miny;
                        cv::rectangle(dstImage,cv::Rect(fusionfbox.minx,fusionfbox.miny,lengthf,widthf),cv::Scalar(0,0,255),3,1,0);

                        std::string text = fusionfbox.Class+"-"+"navi:"+ std::to_string(int(fusionfbox.navi))+" "+"x:"+std::to_string(int(fusionfbox.centerx))+ " "+"y:"+ std::to_string(int(fusionfbox.centery));
                                int font_face = cv::FONT_HERSHEY_COMPLEX;
                                double font_scale = 0.5;  //大小
                                int thickness = 1;
                                int baseline;
                                //获取文本框的长宽  
                                cv::Size text_size = cv::getTextSize(text, font_face, font_scale, thickness, &baseline);
                                cv::Point origin;
                                origin.x = fusionfbox.minx;// - text_size.width / 2;  
                                origin.y = fusionfbox.miny - text_size.height / 2;
                                cv::putText(dstImage, text, origin, font_face, font_scale, cv::Scalar(0, 255, 255), thickness, 8, 0);
	    }
    }
    else if(weight_L!=0&&weight_R==0&&weight_C==0){
        for(int i=0;i<BBL.size();++i)
	    {	        
                        fusionfbox.maxx=BBL[i].maxx;
                        fusionfbox.maxy=BBL[i].maxy;
                        fusionfbox.minx=BBL[i].minx;
                        fusionfbox.miny=BBL[i].miny;
                        fusionfbox.centerx=(fusionfbox.maxx+fusionfbox.minx)/2;
                        fusionfbox.centery=(fusionfbox.maxy+fusionfbox.miny)/2;
                        fusionfbox.navi=BBL[i].navi;
                        //fusionfbox.probability=BBoxes[i].probability;
                        fusionfbox.Class="car";	
                        //=======draw
                        float lengthf= fusionfbox.maxx- fusionfbox.minx;
                                float widthf=  fusionfbox.maxy- fusionfbox.miny;
                        cv::rectangle(dstImage,cv::Rect(fusionfbox.minx,fusionfbox.miny,lengthf,widthf),cv::Scalar(0,0,255),3,1,0);

                        std::string text = fusionfbox.Class+"-"+"navi:"+ std::to_string(int(fusionfbox.navi))+" "+"x:"+std::to_string(int(fusionfbox.centerx))+ " "+"y:"+ std::to_string(int(fusionfbox.centery));
                                int font_face = cv::FONT_HERSHEY_COMPLEX;
                                double font_scale = 0.5;  //大小
                                int thickness = 1;
                                int baseline;
                                //获取文本框的长宽  
                                cv::Size text_size = cv::getTextSize(text, font_face, font_scale, thickness, &baseline);
                                cv::Point origin;
                                origin.x = fusionfbox.minx;// - text_size.width / 2;  
                                origin.y = fusionfbox.miny - text_size.height / 2;
                                cv::putText(dstImage, text, origin, font_face, font_scale, cv::Scalar(0, 255, 255), thickness, 8, 0);
	    }
    }
	sensor_msgs::ImagePtr pubmsg = cv_bridge::CvImage(std_msgs::Header(), "bgr8", dstImage).toImageMsg();
    sensor_msgs::ImagePtr pubmsg2 = cv_bridge::CvImage(std_msgs::Header(), "bgr8", trkImage).toImageMsg();

        pub1.publish(pubmsg);
        pub2.publish(pubmsg2);
        dstImage.release();
        trkImage.release();

	BBoxes.clear();
    output_file.close();
    fangcha_C_out.close();
    x_y.close();
    }
	//融合部分结束.................................................................

    void ROIL2Dcb (const depthGet::BboxLes::ConstPtr& input)
    {
	BBL=input->bboxl;
	BBR=BBL;
	for(int i=0;i<BBR.size();i++){
		srand(time(0));
		BBR[i].maxx=BBR[i].maxx+rand()%11-5;
		BBR[i].minx=BBR[i].minx+rand()%11-5;
		BBR[i].maxy=BBR[i].maxy+rand()%11-5;
		BBR[i].miny=BBR[i].miny+rand()%11-5;
		BBR[i].navi=BBL[i].navi;
		BBR[i].centerx=(BBR[i].maxx+BBR[i].minx)/2;
		BBR[i].centery=(BBR[i].maxy+BBR[i].miny)/2;
		}
    }
    void BBcb(const depthGet::BoundingBoxes::ConstPtr& msg)
    {
	//auto 
//	int *beg=begin(msg->bounding_boxes);
//	int *end=end(msg->bounding_boxes);
	BBoxes=msg->bounding_boxes;
		
/*	for(int i=0;i<msg->bounding_boxes.size();++i)
	{
	   if(msg->bounding_boxes[i].probability>0.4)
	   {
		//msg->bounding_boxes[1].xmin
		// ROS_INFO("I heard: [%d]",msg->bounding_boxes[1].xmin);	
    	float length= msg->bounding_boxes[i].xmax-msg->bounding_boxes[i].xmin;
       	        float width=  msg->bounding_boxes[i].ymax-msg->bounding_boxes[i].ymin;
		cv::rectangle(dstImage,cv::Rect(msg->bounding_boxes[i].xmin,msg->bounding_boxes[i].ymin,length,width),cv::Scalar(0,0,255),2,1,0);
		//设置绘制文本的相关参数  
		std::string text = msg->bounding_boxes[i].Class+"-"+std::to_string(int(100*msg->bounding_boxes[i].probability))+"%";  
		int font_face = cv::FONT_HERSHEY_COMPLEX;   
		double font_scale = 0.5;  //大小
		int thickness = 1;  
		int baseline;  
		//获取文本框的长宽  
		cv::Size text_size = cv::getTextSize(text, font_face, font_scale, thickness, &baseline);
		cv::Point origin;   
		origin.x = msg->bounding_boxes[i].xmin;// - text_size.width / 2;  
		origin.y = msg->bounding_boxes[i].ymin - text_size.height / 2;
		cv::putText(dstImage, text, origin, font_face, font_scale, cv::Scalar(0, 255, 255), thickness, 8, 0); 	  
	  }	
	}
//	cv::imshow("OPENCV_WINDOW",dstImage);
    
	sensor_msgs::ImagePtr pubmsg = cv_bridge::CvImage(std_msgs::Header(), "bgr8", dstImage).toImageMsg();

        pub1.publish(pubmsg);
	dstImage.release();*/
    }
   
    protected:
        ros::NodeHandle nh;
        ros::Subscriber sub2,sub3;
        image_transport::ImageTransport it;
        image_transport::Subscriber sub1;
        image_transport::Publisher pub1;
        image_transport::Publisher pub2;
        struct Bbox{
        float minx_bb =0;
        float maxx_bb =0;
        float miny_bb =0;
        float maxy_bb =0;
        int flag_bb =0;
	};
	struct finalbox{
	float maxx=0;
	float maxy=0;
	float minx=0;
	float miny=0;
	float centerx=0;
	float centery=0;
	float navi=0;
	std::string Class;
	
	};

};

int main (int argc, char** argv)
{
  // Initialize ROS
  
  ros::init (argc, argv, "depthGet");

  DepthHandler handler;
  
  // Spin
  ros::spin ();

  return 0;
}


